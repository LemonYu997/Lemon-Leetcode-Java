package problems.c0easy;

/**
 * 999 可以被一步捕获的棋子数 https://leetcode.cn/problems/available-captures-for-rook/
 * 在一个 8 x 8 的棋盘上，有一个白色的车（Rook），用字符 'R' 表示。
 * 棋盘上还可能存在空方块，白色的象（Bishop）以及黑色的卒（pawn），
 * 分别用字符 '.'，'B' 和 'p' 表示。不难看出，大写字符表示的是白棋，小写字符表示的是黑棋。
 * 车按国际象棋中的规则移动。东，西，南，北四个基本方向任选其一，然后一直向选定的方向移动，
 * 直到满足下列四个条件之一：
 * 1、棋手选择主动停下来。
 * 2、棋子因到达棋盘的边缘而停下。
 * 3、棋子移动到某一方格来捕获位于该方格上敌方（黑色）的卒，停在该方格内。
 * 4、车不能进入/越过已经放有其他友方棋子（白色的象）的方格，停在友方棋子前。
 * 你现在可以控制车移动一次，请你统计有多少敌方的卒处于你的捕获范围内
 * （即，可以被一步捕获的棋子数）。
 *
 * 示例：
 * 输入1：[[".",".",".",".",".",".",".","."],
 * [".",".",".","p",".",".",".","."],
 * [".",".",".","R",".",".",".","p"],
 * [".",".",".",".",".",".",".","."],
 * [".",".",".",".",".",".",".","."],
 * [".",".",".","p",".",".",".","."],
 * [".",".",".",".",".",".",".","."],
 * [".",".",".",".",".",".",".","."]]
 * 输出1：3
 *
 * 输入2：[[".",".",".",".",".",".",".","."],
 * [".","p","p","p","p","p",".","."],
 * [".","p","p","B","p","p",".","."],
 * [".","p","B","R","B","p",".","."],
 * [".","p","p","B","p","p",".","."],
 * [".","p","p","p","p","p",".","."],
 * [".",".",".",".",".",".",".","."],
 * [".",".",".",".",".",".",".","."]]
 * 输出2：0
 *
 * 输入3：[[".",".",".",".",".",".",".","."],
 * [".",".",".","p",".",".",".","."],
 * [".",".",".","p",".",".",".","."],
 * ["p","p",".","R",".","p","B","."],
 * [".",".",".",".",".",".",".","."],
 * [".",".",".","B",".",".",".","."],
 * [".",".",".","p",".",".",".","."],
 * [".",".",".",".",".",".",".","."]]
 * 输出3：3
 */
public class T999 {
    /**
     * 自己实现：先找到R，再向上下左右遍历
     * 如果遇到 p 则计数然后退出循环，如果遇到 B 退出循环
     */
    public int numRookCaptures(char[][] board) {
        int dx[] = {0, 1, 0, -1};
        int dy[] = {1, 0, -1, 0};
        int ans = 0;
        int x = 0;
        int y = 0;
        // 先找到 R 的位置
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[i].length; j++) {
                if (board[i][j] == 'R') {
                    x = i;
                    y = j;
                    break;
                }
            }
        }
        // 再从 x,y 向上下左右遍历
        for (int i = 0; i < 4; i++) {
            // 走的步数
            for (int step = 0; ;step++) {
                int tx = x + step * dx[i];
                int ty = y + step * dy[i];
                // 排除边界情况
                if (tx < 0 || tx >= 8 || ty < 0 || ty >= 8 || board[tx][ty] == 'B') {
                    break;
                }
                // 可以吃，计数
                if (board[tx][ty] == 'p') {
                    ans++;
                    break;
                }
            }
        }
        return ans;
    }
}
